# Kỹ thuật phân tích tĩnh cơ bản cho phân tích mã độc.
Có 2 kỹ thuật chính để phân tích mã độc là *phân tích động (dynamic)* và *phân tích tĩnh (static)*. Phân tích tĩnh liên quan tới việc phân tích mã độc mà không thực thi nó, phân tích mà phải thực thi mã độc thì được gọi là phân tích động.  
## Sử dụng Antivirus  
- Đây được xem là bước khởi đầu trong việc phân tích. Chạy tệp cần phân tích thông qua nhiều bộ công cụ Antivirus có thể giúp chúng ta nhận diện được mã độc.  
- Chúng nhận diện được mã độc dựa trên một tập dữ liệu có sẵn chứa những đoạn code (file signature), những hành vi, những khuôn mẫu (pattern), dựa vào tập dữ liệu này, antivirus sẽ quyết định xem chương trình đang kiểm tra có khả năng là mã độc hay không.  
- Tuy nhiên, những bộ công cụ này không thật sử hoàn hảo do giới hạn của kích thước tập dữ liệu cũng như thời gian cập nhật tập dữ liệu này. Trong khi tác giả của mã độc có thể dễ dàng sửa đổi code và chữ ký của chương trình để trốn tránh Antivirus. Do đó, đối với những mã độc mới, hay những mã độc tinh vi, lạ thì Antivirus hoàn toàn chịu thua.  
- Để tăng tính chính xác khi sử dụng antivirus, chúng ta nên kiểm tra tệp tin trên nhiều công cụ khác nhau. Trang [VirusTotal](https://www.virustotal.com/gui/)  hỗ trợ khá tốt cho việc này.  

## Hashing: A Fingerprint for Malware  
Kỹ thuật này thường dùng cho những mã độc được xem là duy nhất (độc nhất vô nhị). Chúng ta dùng hàm băm (hash) để băm nó ra thành những chuỗi hash duy nhất đại diện cho nó.  
Sau khi có chuỗi này, ta có thể :  
    - Dùng chuỗi này như 1 label, 
    - Gửi cho những chuyên gia phân tích khác nhờ họ giúp.  
    - Thậm chí có thể tìm kiếm trên internet loại mã độc này thông qua chuỗi hash trên.  

## Tìm chuỗi  
- Đây là cách đơn giản để lấy được thông tin cơ bản về chức năng của mã độc. Những chuỗi này có thể là một đoạn thông báo, có thể là tên hàm, có thể là địa chỉ tên miền nào đó...  
- Ví dụ, khi phân tích chuôi của 1 chương trình, ta có các chuỗi sau:  
```
VP3
VW3
t$@
D$4
99.124.22.1
e-@
GetLayout
GDI32.DLL
SetLayout
M}C
Mail system DLL is invalid.!Send Mail failed to send message
```
Trong ví dụ trên, có những chuỗi có nghĩa và cũng có những chuỗi vô nghĩa (VP3, VW3,...). Ta có:  
    - **GetLayout** và **SetLayout** là những hàm được dùng bởi thư viện đồ họa của Windows.  
    - **GDI.DLL** là tên của thư viện liên kết động (dynamic link library) được sử dụng bởi những chương trình đồ họa.  
    - **99.124.22.1** có thể là 1 địa chỉ IP nào đó.
    - **Mail system DLL is invalid.!Send Mail failed to send message** rõ ràng đây là một thông báo lỗi.  
Từ những yếu tố trên, ta có thể dẫn tới kết luận: Mã độc này thực hiện thao tác gửi 1 message (có thể là gửi qua mail) và nó phụ thuộc vào hệ thống mail DLL (thông báo lỗi).  
Từ đó, ta có thể cần phải kiểm tra email log đối với những traffic đáng nghi ngờ, haowjc kiểm tra những DLL khác có thể có liên quan đến mã độc này (như Mail system DLL)  
## Packed và Obfuscated 
- **Obfuscated programs** là những chương trình mà các lệnh thực thi của nó đã bị tác giả cố gắng giấu đi, làm rối để chúng ta khó có thể dịch ngược lại từ binary ban đầu.  
- **Packed program** là tập hợp nhiều Obfuscated programs và mã độc đã bị nén (compress), không thể phân tích.  
Kỹ thuật này mục đích là giúp tác giả của các ứng dụng, phần mềm bảo vệ sản phẩm của họ, không bị ăn cắp, ý tưởng, bản quyền. Tuy nhiên, nó lại bị các tin tặc sử dụng khi viết mã độc, làm khó khăn trong quá trình phân tích chúng, đặc biệt khi chúng ta phân tích tĩnh, kỹ thuật này gây ra rất nhiều khó khăn.  
- Một trong những cách để phát hiện Packers đó là dùng *công cụ PEiD*. Mặc dù công cụ này đã không còn tiếp tục phát triển từ 2011, nhưng ở một khía cạnh nào đó, nó vẫn là một công cụ mạnh để phát hiện packer. Ngoài ra chúng ta có thể nhận diện bằng string, bằng kinh nghiệm của bản thân,...  
- Sau khi phát hiện ra packer, chúng ta cần unpack chúng. Tool [UPX](http://
upx.sourceforge.net/) có thể hỗ trợ chúng ta trong việc này. Tuy nhiên, có những trường hợp công cụ này không hữu hiệu, khi đó chúng ta phải unpack bằng tay.  

## Linked Libraries and Functions  
Đây là mẫu thông tin hữu ích cho việc phân tích nếu chúng ta có được chúng.  
- **Import** là những hàm được sử dụng trong chương trình mà code thực thi của nó lại nằm trong chương trình khác. Quá trình chương trình đang thực thi gọi những hàm này từ chương trình khác gọi là **linking**.  Chúng ta có các loại linking như:  
    - *Static linking*: phương pháp thường dùng trong các chương trình Linux, UNIX. Khi một library linking tới file thực thi (executable) thì nó sẽ copy tất cả các code của library bỏ vào file thực thi, sau đó mới thực thi file này. Phương pháp này làm cho kích thước của file tăng lên, gây khó khăn khi phân tích vì không phân biệt được code nào của file thực thi, code nào của thư viện hỗ trơ. Tuy nhiên, phương pháp này không thường hay sử dụng để viết mã độc, vì dễ bị phát hiện do kích thước tăng đáng kể.  
    - *Runtime linking*: thường được dùng trong viết mã độc, đặc biệt là mã độc có sử dụng kỹ thuật packed và obfuscated. Chương trình thực thi sẽ thực hiện bình thường, đến khi nào cần dùng hàm ở trong thư viện thì nó mới copy đoạn mã thực thi của hàm đó bỏ vào rồi thực thi tiếp.  
    - *Dynamic linking*: khi thực hiện phương pháp này, hệ điều hành sẽ tìm những thư viện đã được liên kết với chương trình thực thi, khi chương trình thực thi đến những hàm được liên kết, hệ điều hành sẽ chuyển qua thực thi trong thư viện rồi trả kết quả về cho chương trình thực thi để tiếp tục. Phương pháp này thường được sử dụng nhiều nhất trong viết mã độc và phân tích mã độc.  
PE file header lưu thông tin về những thư viện được load và những hàm sẽ được sử dụng bởi chương trình. Đối với mã độc, thường những thư viện, hàm được gọi này là những phần rất quan trọng. Do đó, phát hiện chúng có thể giúp chúng ta dự đoán được hành vi của chương trình đang phân tích.  
- Exported Functions:
    - Như import, DLLs và EXEs cung có những hàm cho phép những chương trình thực thi khác có thể gọi và sử dụng. Thông thường, DLLs sẽ hiện thực một vài functions và export chúng để các file thực thi khác có thể import và sử dụng.  
    - File PE chứa thông tin về những function mà file export.  
    - Vì DLLs được hiện thực với mục đích là export những function cho các file thực thi, vì thế trong file thực thi khác (EXEs,...) thường hiếm khi xuất hiện export function. Do đó, trong quá trình phân tích nếu bạn thấy có sự xuất hiện của export function, nó sẽ cũng cấp cho bạn khá nhiều thông tin hữu ích.  

## Ví dụ về phân mã độc bằng phương pháp tĩnh
### PotentialKeylogger.exe: An Unpacked Executable
---
Chúng ta sẽ tiến hành phân tích mã độc **PotentialKeylogger.exe: An Unpacked Executable**  
- Đầu tiên, dùng *Dependency Wlaker* để lấy được danh sách các import function.  
- Những imports trong **Kernel32.dll**: cho chúng ta biết rằng phần mềm này có thể mở và chỉnh sửa các process (OpenProcess, GetCurrentProcess, GetProcessHeap) và files (ReadFile, CreateFile, WriteFile). Những hàm: *FindFirstFile* và *FindNextFile* khá thú vị để mà chúng ta sử dụng để tìm kiếm thông qua thư mục.  
- Trong **User32.dll**: có nhiều hàm liên quan đến thao tác với GUI (RegisterClassEx, SetWindowText, ShowWindow)  cho thấy khả năng cao chương trình này có GUI.  
- Hàm **SetWindowsHookEx** thường được sử dụng trong các spyware và nó là cách phổ biến mà keylogger sử dụng để ghi lại các phím chúng ta đã nhập. Mặc dùng hàm này được sử dụng hợp lệ, nhưng nếu chúng ta đã xác định chương trình chúng ta đã kiểm tra là chương trình độc hại, và thấy hàm này thì khả năng cao nó là 1 chức năng của keylogger.  
- Hàm **RegisterHotKey** dùng để đưang kí 1 hotkey (tổ hợp phím) để mà bất cứ khi nào người dùng bấm vào tổ hợp phím này, chương trình sẽ được thông báo. Sự lợi hại của hotkey đó là dù cho bạn đang thực thi bất kì chương trình nào đi nữa, khi bấm nó, nó đều có thể chuyển phiên làm việc của người dùng đến ứng dụng của nó.  
- Imports từ **GDI32.dll** là những hàm liên quan đến đồ họa, cho thấy chương trình này có thể có GUI, còn imports từ **Shell32.dll** cho thấy chương trình này có thể được thực thi bởi chương trình khác. Những tính năng này đều thường được sử dụng trong cả chương trình bình thường và mã độc.  
- Imports từ **Advapi32.dll** cho thấy chương trình này sử dụng registry, do đó, chúng ta nên đi tìm các chuỗi giống như registry keys. Những chuỗi này giống như địa chỉ của thư mục. Trong trường hợp này, chúng ta tìm thấy: *Software\Microsoft\Windows\CurrentVersion\Run*, register key này cho phép chương trình được tự động chạy ngay khi Windows khởi động.  
- Ngoài ra, file thực thi này còn có nhiều exports: *LowLevelKeyboardProc* và *LowLevelMouseProc*. Những hàm này được dùng với *SetWindowsHookEx* để chỉ đặc tả 1 sự kiện xảy ra - trường hợp này là 1 sự kiện gõ phím.  

Từ những thông tin trên, ta có những kết luận sau:  
Đây có thể là 1 local keylogger sử dụng SetWindowsHookEx để ghi lại những phím đã nhập. Ngoài ra nó có thể có GUI, và hotkey được đăng kí để mở GUI này lên. Kẻ tấn công có thể dùng GUI này để xem lại tất cả những phím mà nạn nhân gõ được record lại bởi keylogger. Bên cạnh đó, chương trình này cũng được đăng kí trong  *Software\Microsoft\Windows\CurrentVersion\Run* để có thể tự động chạy mỗi khi hệ thống khởi động.  

### PackedProgram.exe: A Dead End
---
Tiếp sau đây, ta thử phân tích một mã độc đã được Packed.  
Ta dùng Dependency Walker để lấy thông tin và được như bảng sau:  
![Image](https://developers.google.com/maps/documentation/streetview/images/error-image-generic.png)  
- Quá ngắn gọn và không có nhiều thông tin, search string cũng không thấy có nhiều string có thể đọc được. Windows compiler sẽ không tạo ra một chương trình nào mà chỉ import một vài hàm như trên (thậm chí là chương trình HelloWorld), do đó có thể kết luận chương trình này đã bị packed.  
- Khi mà chương trình bị packed thì phương pháp này hoàn toàn vô hiệu, lúc này ta cần nhiều kỹ thuật cao hơn. Những kỹ thuật này tôi sẽ trình bày ở những phần sau.  
